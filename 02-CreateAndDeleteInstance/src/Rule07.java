/**
 * Created by gunny on 2017. 7. 24..
 *
 * 7. 종료자 사용을 피하라.
 *
 * 종료자(finalizer)는 예측 불가능하며, 대체로 위험하고, 일반적으로 불필요하다.
 * 종료자를 사용하면 시스템오류, 성능 문제, 이식성 문제가 발생할 수 있다.
 *
 * 1.종료자의 한가지 단점은, 즉시 실행되리라는 보장이 전혀 없다는 것이다.
 *   어떤 객체에 대한 모든 참조가 사라지고 나서 종료자가 실행되기 까지는 긴 시간이 걸릴 수 있다.
 *   따라서 긴급한 작업을 종료자 안에서 처리하면 안된다.
 *   예를 들어, 종료자 안에서 파일을 닫도록 하면 치명적이다.
 *
 *   중요상태 정보는 종료자로 갱신하면 안된다. 예를 들어 분산 시스템 전체를 먹통으로 만드는 가장 좋은 방법은
 *   데이터베이스 같은 공유 자원에 대한 지속성 락을 종료자가 반환하게 구현하는 것이다.
 *   System.gc나 System.runFinalization 같은 메소드에 마음이 흔들리면 곤란하다.
 *   이런 메서드들은 종료자가 실행될 가능성을 높여주긴 하지만 보장하진않는다.
 *
 * 2. 종료자를 사용하면 프로그램 성능이 심각하게 떨어진다.
 *    종료자 대신 그냥, 명시적인 종료 메소드를 하나 정의하고, 더이상 필요하지 않는 객체라면
 *    클라이언트가 해당 메소드를 호출하도록 하라. 한가지 명심할 것은 종료 여부를 객체안에 보관해야 한다는 것.
 *    즉, 유효하지 않은 객체임을 표시하는 private필드를 하나두고, 모든 메소드 앞에 해당 필드를 검사하는 코드를
 *    두어, 이미 종료된 객체에 메소드를 호출하면 IllegalStateException이 던져지도록 해야 한다는 것이다.
 *
 * 3. 이런 명시적 종료 메소드는 보통 try-finally 문과 함께 쓰인다. 객체 종료를 보장하기 위해서다.
 */
public class Rule07 {
    public static void main(String args[]) {

    }

    // 수동 종료자 연결
    /*
        객체가 소멸되기 전에 다른 자원도 정리해야 한다면, finalize 메소드를 재정의해 사용할 수 있다.
        즉, 명시적인 종결처리 메소드를 호출하는 것을 잊었을 경우에 대비해 안전망 역할을 할 수 있다.
        하지만, 이것 또한 종료자가 바로 호출되거나, 반드시 호출된다는 보장은 없다.
     */
    @Override
    protected void finalize() throws Throwable {
        try {
            close();
        } finally {
            super.finalize();
        }
    }
}
